/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.events = (function() {

    /**
     * Namespace events.
     * @exports events
     * @namespace
     */
    var events = {};

    events.Core = (function() {

        /**
         * Properties of a Core.
         * @memberof events
         * @interface ICore
         * @property {string|null} [id] Read-only and auto-generated. ID of the message, ID is a uuid v4 auto-generated by messaging library.
         * It will be propagate through the system
         * @property {string|null} [name] Read-only and auto-generated. The name of the event is automatically computed based on
         * Protobuf data structure in {VtEvent.data}
         * @property {string|null} [timestamp] Read-only and auto-generated. Messaging library will compute the timestamp in UTC when a message is produced.
         */

        /**
         * Constructs a new Core.
         * @memberof events
         * @classdesc Represents a Core.
         * @implements ICore
         * @constructor
         * @param {events.ICore=} [properties] Properties to set
         */
        function Core(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Read-only and auto-generated. ID of the message, ID is a uuid v4 auto-generated by messaging library.
         * It will be propagate through the system
         * @member {string} id
         * @memberof events.Core
         * @instance
         */
        Core.prototype.id = "";

        /**
         * Read-only and auto-generated. The name of the event is automatically computed based on
         * Protobuf data structure in {VtEvent.data}
         * @member {string} name
         * @memberof events.Core
         * @instance
         */
        Core.prototype.name = "";

        /**
         * Read-only and auto-generated. Messaging library will compute the timestamp in UTC when a message is produced.
         * @member {string} timestamp
         * @memberof events.Core
         * @instance
         */
        Core.prototype.timestamp = "";

        /**
         * Creates a new Core instance using the specified properties.
         * @function create
         * @memberof events.Core
         * @static
         * @param {events.ICore=} [properties] Properties to set
         * @returns {events.Core} Core instance
         */
        Core.create = function create(properties) {
            return new Core(properties);
        };

        /**
         * Encodes the specified Core message. Does not implicitly {@link events.Core.verify|verify} messages.
         * @function encode
         * @memberof events.Core
         * @static
         * @param {events.ICore} message Core message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Core.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Core message, length delimited. Does not implicitly {@link events.Core.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.Core
         * @static
         * @param {events.ICore} message Core message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Core.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Core message from the specified reader or buffer.
         * @function decode
         * @memberof events.Core
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.Core} Core
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Core.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.Core();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Core message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.Core
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.Core} Core
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Core.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Core message.
         * @function verify
         * @memberof events.Core
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Core.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isString(message.timestamp))
                    return "timestamp: string expected";
            return null;
        };

        /**
         * Creates a Core message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.Core
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.Core} Core
         */
        Core.fromObject = function fromObject(object) {
            if (object instanceof $root.events.Core)
                return object;
            var message = new $root.events.Core();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.timestamp != null)
                message.timestamp = String(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Core message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.Core
         * @static
         * @param {events.Core} message Core
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Core.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.timestamp = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            return object;
        };

        /**
         * Converts this Core to JSON.
         * @function toJSON
         * @memberof events.Core
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Core.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Core;
    })();

    events.Trace = (function() {

        /**
         * Properties of a Trace.
         * @memberof events
         * @interface ITrace
         * @property {Object.<string,string>|null} [traceContext] Open Tracing trace context.
         * @property {Object.<string,string>|null} [traceTags] Trace traceTags
         * @property {string|null} [serviceName] Trace serviceName
         */

        /**
         * Constructs a new Trace.
         * @memberof events
         * @classdesc Represents a Trace.
         * @implements ITrace
         * @constructor
         * @param {events.ITrace=} [properties] Properties to set
         */
        function Trace(properties) {
            this.traceContext = {};
            this.traceTags = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Open Tracing trace context.
         * @member {Object.<string,string>} traceContext
         * @memberof events.Trace
         * @instance
         */
        Trace.prototype.traceContext = $util.emptyObject;

        /**
         * Trace traceTags.
         * @member {Object.<string,string>} traceTags
         * @memberof events.Trace
         * @instance
         */
        Trace.prototype.traceTags = $util.emptyObject;

        /**
         * Trace serviceName.
         * @member {string} serviceName
         * @memberof events.Trace
         * @instance
         */
        Trace.prototype.serviceName = "";

        /**
         * Creates a new Trace instance using the specified properties.
         * @function create
         * @memberof events.Trace
         * @static
         * @param {events.ITrace=} [properties] Properties to set
         * @returns {events.Trace} Trace instance
         */
        Trace.create = function create(properties) {
            return new Trace(properties);
        };

        /**
         * Encodes the specified Trace message. Does not implicitly {@link events.Trace.verify|verify} messages.
         * @function encode
         * @memberof events.Trace
         * @static
         * @param {events.ITrace} message Trace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.traceContext != null && message.hasOwnProperty("traceContext"))
                for (var keys = Object.keys(message.traceContext), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.traceContext[keys[i]]).ldelim();
            if (message.traceTags != null && message.hasOwnProperty("traceTags"))
                for (var keys = Object.keys(message.traceTags), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.traceTags[keys[i]]).ldelim();
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.serviceName);
            return writer;
        };

        /**
         * Encodes the specified Trace message, length delimited. Does not implicitly {@link events.Trace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.Trace
         * @static
         * @param {events.ITrace} message Trace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Trace message from the specified reader or buffer.
         * @function decode
         * @memberof events.Trace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.Trace} Trace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.Trace(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.traceContext === $util.emptyObject)
                        message.traceContext = {};
                    key = reader.string();
                    reader.pos++;
                    message.traceContext[key] = reader.string();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.traceTags === $util.emptyObject)
                        message.traceTags = {};
                    key = reader.string();
                    reader.pos++;
                    message.traceTags[key] = reader.string();
                    break;
                case 3:
                    message.serviceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Trace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.Trace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.Trace} Trace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Trace message.
         * @function verify
         * @memberof events.Trace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Trace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.traceContext != null && message.hasOwnProperty("traceContext")) {
                if (!$util.isObject(message.traceContext))
                    return "traceContext: object expected";
                var key = Object.keys(message.traceContext);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.traceContext[key[i]]))
                        return "traceContext: string{k:string} expected";
            }
            if (message.traceTags != null && message.hasOwnProperty("traceTags")) {
                if (!$util.isObject(message.traceTags))
                    return "traceTags: object expected";
                var key = Object.keys(message.traceTags);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.traceTags[key[i]]))
                        return "traceTags: string{k:string} expected";
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                if (!$util.isString(message.serviceName))
                    return "serviceName: string expected";
            return null;
        };

        /**
         * Creates a Trace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.Trace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.Trace} Trace
         */
        Trace.fromObject = function fromObject(object) {
            if (object instanceof $root.events.Trace)
                return object;
            var message = new $root.events.Trace();
            if (object.traceContext) {
                if (typeof object.traceContext !== "object")
                    throw TypeError(".events.Trace.traceContext: object expected");
                message.traceContext = {};
                for (var keys = Object.keys(object.traceContext), i = 0; i < keys.length; ++i)
                    message.traceContext[keys[i]] = String(object.traceContext[keys[i]]);
            }
            if (object.traceTags) {
                if (typeof object.traceTags !== "object")
                    throw TypeError(".events.Trace.traceTags: object expected");
                message.traceTags = {};
                for (var keys = Object.keys(object.traceTags), i = 0; i < keys.length; ++i)
                    message.traceTags[keys[i]] = String(object.traceTags[keys[i]]);
            }
            if (object.serviceName != null)
                message.serviceName = String(object.serviceName);
            return message;
        };

        /**
         * Creates a plain object from a Trace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.Trace
         * @static
         * @param {events.Trace} message Trace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Trace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.traceContext = {};
                object.traceTags = {};
            }
            if (options.defaults)
                object.serviceName = "";
            var keys2;
            if (message.traceContext && (keys2 = Object.keys(message.traceContext)).length) {
                object.traceContext = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.traceContext[keys2[j]] = message.traceContext[keys2[j]];
            }
            if (message.traceTags && (keys2 = Object.keys(message.traceTags)).length) {
                object.traceTags = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.traceTags[keys2[j]] = message.traceTags[keys2[j]];
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                object.serviceName = message.serviceName;
            return object;
        };

        /**
         * Converts this Trace to JSON.
         * @function toJSON
         * @memberof events.Trace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Trace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Trace;
    })();

    events.VtEvent = (function() {

        /**
         * Properties of a VtEvent.
         * @memberof events
         * @interface IVtEvent
         * @property {events.ICore|null} [core] VtEvent core
         * @property {events.ITrace|null} [trace] VtEvent trace
         * @property {google.protobuf.IAny|null} [data] VtEvent data
         */

        /**
         * Constructs a new VtEvent.
         * @memberof events
         * @classdesc Represents a VtEvent.
         * @implements IVtEvent
         * @constructor
         * @param {events.IVtEvent=} [properties] Properties to set
         */
        function VtEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VtEvent core.
         * @member {events.ICore|null|undefined} core
         * @memberof events.VtEvent
         * @instance
         */
        VtEvent.prototype.core = null;

        /**
         * VtEvent trace.
         * @member {events.ITrace|null|undefined} trace
         * @memberof events.VtEvent
         * @instance
         */
        VtEvent.prototype.trace = null;

        /**
         * VtEvent data.
         * @member {google.protobuf.IAny|null|undefined} data
         * @memberof events.VtEvent
         * @instance
         */
        VtEvent.prototype.data = null;

        /**
         * Creates a new VtEvent instance using the specified properties.
         * @function create
         * @memberof events.VtEvent
         * @static
         * @param {events.IVtEvent=} [properties] Properties to set
         * @returns {events.VtEvent} VtEvent instance
         */
        VtEvent.create = function create(properties) {
            return new VtEvent(properties);
        };

        /**
         * Encodes the specified VtEvent message. Does not implicitly {@link events.VtEvent.verify|verify} messages.
         * @function encode
         * @memberof events.VtEvent
         * @static
         * @param {events.IVtEvent} message VtEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VtEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.core != null && message.hasOwnProperty("core"))
                $root.events.Core.encode(message.core, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trace != null && message.hasOwnProperty("trace"))
                $root.events.Trace.encode(message.trace, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.google.protobuf.Any.encode(message.data, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VtEvent message, length delimited. Does not implicitly {@link events.VtEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.VtEvent
         * @static
         * @param {events.IVtEvent} message VtEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VtEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VtEvent message from the specified reader or buffer.
         * @function decode
         * @memberof events.VtEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.VtEvent} VtEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VtEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.VtEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.core = $root.events.Core.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trace = $root.events.Trace.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.data = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VtEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.VtEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.VtEvent} VtEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VtEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VtEvent message.
         * @function verify
         * @memberof events.VtEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VtEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.core != null && message.hasOwnProperty("core")) {
                var error = $root.events.Core.verify(message.core);
                if (error)
                    return "core." + error;
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
                var error = $root.events.Trace.verify(message.trace);
                if (error)
                    return "trace." + error;
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                var error = $root.google.protobuf.Any.verify(message.data);
                if (error)
                    return "data." + error;
            }
            return null;
        };

        /**
         * Creates a VtEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.VtEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.VtEvent} VtEvent
         */
        VtEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.events.VtEvent)
                return object;
            var message = new $root.events.VtEvent();
            if (object.core != null) {
                if (typeof object.core !== "object")
                    throw TypeError(".events.VtEvent.core: object expected");
                message.core = $root.events.Core.fromObject(object.core);
            }
            if (object.trace != null) {
                if (typeof object.trace !== "object")
                    throw TypeError(".events.VtEvent.trace: object expected");
                message.trace = $root.events.Trace.fromObject(object.trace);
            }
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".events.VtEvent.data: object expected");
                message.data = $root.google.protobuf.Any.fromObject(object.data);
            }
            return message;
        };

        /**
         * Creates a plain object from a VtEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.VtEvent
         * @static
         * @param {events.VtEvent} message VtEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VtEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.core = null;
                object.trace = null;
                object.data = null;
            }
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = $root.events.Core.toObject(message.core, options);
            if (message.trace != null && message.hasOwnProperty("trace"))
                object.trace = $root.events.Trace.toObject(message.trace, options);
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = $root.google.protobuf.Any.toObject(message.data, options);
            return object;
        };

        /**
         * Converts this VtEvent to JSON.
         * @function toJSON
         * @memberof events.VtEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VtEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VtEvent;
    })();

    events.ExampleEvent = (function() {

        /**
         * Properties of an ExampleEvent.
         * @memberof events
         * @interface IExampleEvent
         * @property {events.ICore|null} [core] ExampleEvent core
         * @property {string|null} [firstName] ExampleEvent firstName
         * @property {string|null} [lastName] ExampleEvent lastName
         */

        /**
         * Constructs a new ExampleEvent.
         * @memberof events
         * @classdesc Represents an ExampleEvent.
         * @implements IExampleEvent
         * @constructor
         * @param {events.IExampleEvent=} [properties] Properties to set
         */
        function ExampleEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExampleEvent core.
         * @member {events.ICore|null|undefined} core
         * @memberof events.ExampleEvent
         * @instance
         */
        ExampleEvent.prototype.core = null;

        /**
         * ExampleEvent firstName.
         * @member {string} firstName
         * @memberof events.ExampleEvent
         * @instance
         */
        ExampleEvent.prototype.firstName = "";

        /**
         * ExampleEvent lastName.
         * @member {string} lastName
         * @memberof events.ExampleEvent
         * @instance
         */
        ExampleEvent.prototype.lastName = "";

        /**
         * Creates a new ExampleEvent instance using the specified properties.
         * @function create
         * @memberof events.ExampleEvent
         * @static
         * @param {events.IExampleEvent=} [properties] Properties to set
         * @returns {events.ExampleEvent} ExampleEvent instance
         */
        ExampleEvent.create = function create(properties) {
            return new ExampleEvent(properties);
        };

        /**
         * Encodes the specified ExampleEvent message. Does not implicitly {@link events.ExampleEvent.verify|verify} messages.
         * @function encode
         * @memberof events.ExampleEvent
         * @static
         * @param {events.IExampleEvent} message ExampleEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.core != null && message.hasOwnProperty("core"))
                $root.events.Core.encode(message.core, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.firstName);
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.lastName);
            return writer;
        };

        /**
         * Encodes the specified ExampleEvent message, length delimited. Does not implicitly {@link events.ExampleEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ExampleEvent
         * @static
         * @param {events.IExampleEvent} message ExampleEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExampleEvent message from the specified reader or buffer.
         * @function decode
         * @memberof events.ExampleEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ExampleEvent} ExampleEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ExampleEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.core = $root.events.Core.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.firstName = reader.string();
                    break;
                case 3:
                    message.lastName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExampleEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ExampleEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ExampleEvent} ExampleEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExampleEvent message.
         * @function verify
         * @memberof events.ExampleEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExampleEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.core != null && message.hasOwnProperty("core")) {
                var error = $root.events.Core.verify(message.core);
                if (error)
                    return "core." + error;
            }
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                if (!$util.isString(message.firstName))
                    return "firstName: string expected";
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                if (!$util.isString(message.lastName))
                    return "lastName: string expected";
            return null;
        };

        /**
         * Creates an ExampleEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ExampleEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ExampleEvent} ExampleEvent
         */
        ExampleEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ExampleEvent)
                return object;
            var message = new $root.events.ExampleEvent();
            if (object.core != null) {
                if (typeof object.core !== "object")
                    throw TypeError(".events.ExampleEvent.core: object expected");
                message.core = $root.events.Core.fromObject(object.core);
            }
            if (object.firstName != null)
                message.firstName = String(object.firstName);
            if (object.lastName != null)
                message.lastName = String(object.lastName);
            return message;
        };

        /**
         * Creates a plain object from an ExampleEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ExampleEvent
         * @static
         * @param {events.ExampleEvent} message ExampleEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExampleEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.core = null;
                object.firstName = "";
                object.lastName = "";
            }
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = $root.events.Core.toObject(message.core, options);
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                object.firstName = message.firstName;
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                object.lastName = message.lastName;
            return object;
        };

        /**
         * Converts this ExampleEvent to JSON.
         * @function toJSON
         * @memberof events.ExampleEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExampleEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExampleEvent;
    })();

    events.ExampleOne = (function() {

        /**
         * Properties of an ExampleOne.
         * @memberof events
         * @interface IExampleOne
         * @property {string|null} [data] ExampleOne data
         */

        /**
         * Constructs a new ExampleOne.
         * @memberof events
         * @classdesc Represents an ExampleOne.
         * @implements IExampleOne
         * @constructor
         * @param {events.IExampleOne=} [properties] Properties to set
         */
        function ExampleOne(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExampleOne data.
         * @member {string} data
         * @memberof events.ExampleOne
         * @instance
         */
        ExampleOne.prototype.data = "";

        /**
         * Creates a new ExampleOne instance using the specified properties.
         * @function create
         * @memberof events.ExampleOne
         * @static
         * @param {events.IExampleOne=} [properties] Properties to set
         * @returns {events.ExampleOne} ExampleOne instance
         */
        ExampleOne.create = function create(properties) {
            return new ExampleOne(properties);
        };

        /**
         * Encodes the specified ExampleOne message. Does not implicitly {@link events.ExampleOne.verify|verify} messages.
         * @function encode
         * @memberof events.ExampleOne
         * @static
         * @param {events.IExampleOne} message ExampleOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleOne.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified ExampleOne message, length delimited. Does not implicitly {@link events.ExampleOne.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ExampleOne
         * @static
         * @param {events.IExampleOne} message ExampleOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleOne.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExampleOne message from the specified reader or buffer.
         * @function decode
         * @memberof events.ExampleOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ExampleOne} ExampleOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleOne.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ExampleOne();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExampleOne message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ExampleOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ExampleOne} ExampleOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleOne.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExampleOne message.
         * @function verify
         * @memberof events.ExampleOne
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExampleOne.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        /**
         * Creates an ExampleOne message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ExampleOne
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ExampleOne} ExampleOne
         */
        ExampleOne.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ExampleOne)
                return object;
            var message = new $root.events.ExampleOne();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an ExampleOne message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ExampleOne
         * @static
         * @param {events.ExampleOne} message ExampleOne
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExampleOne.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.data = "";
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this ExampleOne to JSON.
         * @function toJSON
         * @memberof events.ExampleOne
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExampleOne.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExampleOne;
    })();

    events.ExampleTwo = (function() {

        /**
         * Properties of an ExampleTwo.
         * @memberof events
         * @interface IExampleTwo
         * @property {number|Long|null} [number] ExampleTwo number
         */

        /**
         * Constructs a new ExampleTwo.
         * @memberof events
         * @classdesc Represents an ExampleTwo.
         * @implements IExampleTwo
         * @constructor
         * @param {events.IExampleTwo=} [properties] Properties to set
         */
        function ExampleTwo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExampleTwo number.
         * @member {number|Long} number
         * @memberof events.ExampleTwo
         * @instance
         */
        ExampleTwo.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExampleTwo instance using the specified properties.
         * @function create
         * @memberof events.ExampleTwo
         * @static
         * @param {events.IExampleTwo=} [properties] Properties to set
         * @returns {events.ExampleTwo} ExampleTwo instance
         */
        ExampleTwo.create = function create(properties) {
            return new ExampleTwo(properties);
        };

        /**
         * Encodes the specified ExampleTwo message. Does not implicitly {@link events.ExampleTwo.verify|verify} messages.
         * @function encode
         * @memberof events.ExampleTwo
         * @static
         * @param {events.IExampleTwo} message ExampleTwo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleTwo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.number != null && message.hasOwnProperty("number"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.number);
            return writer;
        };

        /**
         * Encodes the specified ExampleTwo message, length delimited. Does not implicitly {@link events.ExampleTwo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ExampleTwo
         * @static
         * @param {events.IExampleTwo} message ExampleTwo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleTwo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExampleTwo message from the specified reader or buffer.
         * @function decode
         * @memberof events.ExampleTwo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ExampleTwo} ExampleTwo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleTwo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ExampleTwo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.number = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExampleTwo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ExampleTwo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ExampleTwo} ExampleTwo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleTwo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExampleTwo message.
         * @function verify
         * @memberof events.ExampleTwo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExampleTwo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                    return "number: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExampleTwo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ExampleTwo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ExampleTwo} ExampleTwo
         */
        ExampleTwo.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ExampleTwo)
                return object;
            var message = new $root.events.ExampleTwo();
            if (object.number != null)
                if ($util.Long)
                    (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                else if (typeof object.number === "string")
                    message.number = parseInt(object.number, 10);
                else if (typeof object.number === "number")
                    message.number = object.number;
                else if (typeof object.number === "object")
                    message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExampleTwo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ExampleTwo
         * @static
         * @param {events.ExampleTwo} message ExampleTwo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExampleTwo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.number = options.longs === String ? "0" : 0;
            if (message.number != null && message.hasOwnProperty("number"))
                if (typeof message.number === "number")
                    object.number = options.longs === String ? String(message.number) : message.number;
                else
                    object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
            return object;
        };

        /**
         * Converts this ExampleTwo to JSON.
         * @function toJSON
         * @memberof events.ExampleTwo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExampleTwo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExampleTwo;
    })();

    events.ExampleThree = (function() {

        /**
         * Properties of an ExampleThree.
         * @memberof events
         * @interface IExampleThree
         * @property {boolean|null} [boolean] ExampleThree boolean
         */

        /**
         * Constructs a new ExampleThree.
         * @memberof events
         * @classdesc Represents an ExampleThree.
         * @implements IExampleThree
         * @constructor
         * @param {events.IExampleThree=} [properties] Properties to set
         */
        function ExampleThree(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExampleThree boolean.
         * @member {boolean} boolean
         * @memberof events.ExampleThree
         * @instance
         */
        ExampleThree.prototype.boolean = false;

        /**
         * Creates a new ExampleThree instance using the specified properties.
         * @function create
         * @memberof events.ExampleThree
         * @static
         * @param {events.IExampleThree=} [properties] Properties to set
         * @returns {events.ExampleThree} ExampleThree instance
         */
        ExampleThree.create = function create(properties) {
            return new ExampleThree(properties);
        };

        /**
         * Encodes the specified ExampleThree message. Does not implicitly {@link events.ExampleThree.verify|verify} messages.
         * @function encode
         * @memberof events.ExampleThree
         * @static
         * @param {events.IExampleThree} message ExampleThree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleThree.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.boolean);
            return writer;
        };

        /**
         * Encodes the specified ExampleThree message, length delimited. Does not implicitly {@link events.ExampleThree.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ExampleThree
         * @static
         * @param {events.IExampleThree} message ExampleThree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleThree.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExampleThree message from the specified reader or buffer.
         * @function decode
         * @memberof events.ExampleThree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ExampleThree} ExampleThree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleThree.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ExampleThree();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.boolean = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExampleThree message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ExampleThree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ExampleThree} ExampleThree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleThree.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExampleThree message.
         * @function verify
         * @memberof events.ExampleThree
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExampleThree.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                if (typeof message.boolean !== "boolean")
                    return "boolean: boolean expected";
            return null;
        };

        /**
         * Creates an ExampleThree message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ExampleThree
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ExampleThree} ExampleThree
         */
        ExampleThree.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ExampleThree)
                return object;
            var message = new $root.events.ExampleThree();
            if (object.boolean != null)
                message.boolean = Boolean(object.boolean);
            return message;
        };

        /**
         * Creates a plain object from an ExampleThree message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ExampleThree
         * @static
         * @param {events.ExampleThree} message ExampleThree
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExampleThree.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.boolean = false;
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                object.boolean = message.boolean;
            return object;
        };

        /**
         * Converts this ExampleThree to JSON.
         * @function toJSON
         * @memberof events.ExampleThree
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExampleThree.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExampleThree;
    })();

    events.ExampleFour = (function() {

        /**
         * Properties of an ExampleFour.
         * @memberof events
         * @interface IExampleFour
         * @property {string|null} [data] ExampleFour data
         * @property {number|Long|null} [number] ExampleFour number
         * @property {boolean|null} [boolean] ExampleFour boolean
         */

        /**
         * Constructs a new ExampleFour.
         * @memberof events
         * @classdesc Represents an ExampleFour.
         * @implements IExampleFour
         * @constructor
         * @param {events.IExampleFour=} [properties] Properties to set
         */
        function ExampleFour(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExampleFour data.
         * @member {string} data
         * @memberof events.ExampleFour
         * @instance
         */
        ExampleFour.prototype.data = "";

        /**
         * ExampleFour number.
         * @member {number|Long} number
         * @memberof events.ExampleFour
         * @instance
         */
        ExampleFour.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExampleFour boolean.
         * @member {boolean} boolean
         * @memberof events.ExampleFour
         * @instance
         */
        ExampleFour.prototype.boolean = false;

        /**
         * Creates a new ExampleFour instance using the specified properties.
         * @function create
         * @memberof events.ExampleFour
         * @static
         * @param {events.IExampleFour=} [properties] Properties to set
         * @returns {events.ExampleFour} ExampleFour instance
         */
        ExampleFour.create = function create(properties) {
            return new ExampleFour(properties);
        };

        /**
         * Encodes the specified ExampleFour message. Does not implicitly {@link events.ExampleFour.verify|verify} messages.
         * @function encode
         * @memberof events.ExampleFour
         * @static
         * @param {events.IExampleFour} message ExampleFour message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleFour.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            if (message.number != null && message.hasOwnProperty("number"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.number);
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolean);
            return writer;
        };

        /**
         * Encodes the specified ExampleFour message, length delimited. Does not implicitly {@link events.ExampleFour.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.ExampleFour
         * @static
         * @param {events.IExampleFour} message ExampleFour message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExampleFour.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExampleFour message from the specified reader or buffer.
         * @function decode
         * @memberof events.ExampleFour
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.ExampleFour} ExampleFour
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleFour.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.ExampleFour();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.data = reader.string();
                    break;
                case 3:
                    message.number = reader.int64();
                    break;
                case 4:
                    message.boolean = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExampleFour message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.ExampleFour
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.ExampleFour} ExampleFour
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExampleFour.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExampleFour message.
         * @function verify
         * @memberof events.ExampleFour
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExampleFour.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            if (message.number != null && message.hasOwnProperty("number"))
                if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                    return "number: integer|Long expected";
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                if (typeof message.boolean !== "boolean")
                    return "boolean: boolean expected";
            return null;
        };

        /**
         * Creates an ExampleFour message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.ExampleFour
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.ExampleFour} ExampleFour
         */
        ExampleFour.fromObject = function fromObject(object) {
            if (object instanceof $root.events.ExampleFour)
                return object;
            var message = new $root.events.ExampleFour();
            if (object.data != null)
                message.data = String(object.data);
            if (object.number != null)
                if ($util.Long)
                    (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                else if (typeof object.number === "string")
                    message.number = parseInt(object.number, 10);
                else if (typeof object.number === "number")
                    message.number = object.number;
                else if (typeof object.number === "object")
                    message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
            if (object.boolean != null)
                message.boolean = Boolean(object.boolean);
            return message;
        };

        /**
         * Creates a plain object from an ExampleFour message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.ExampleFour
         * @static
         * @param {events.ExampleFour} message ExampleFour
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExampleFour.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.data = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.number = options.longs === String ? "0" : 0;
                object.boolean = false;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.number != null && message.hasOwnProperty("number"))
                if (typeof message.number === "number")
                    object.number = options.longs === String ? String(message.number) : message.number;
                else
                    object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
            if (message.boolean != null && message.hasOwnProperty("boolean"))
                object.boolean = message.boolean;
            return object;
        };

        /**
         * Converts this ExampleFour to JSON.
         * @function toJSON
         * @memberof events.ExampleFour
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExampleFour.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExampleFour;
    })();

    events.MentionEmailGenerated = (function() {

        /**
         * Properties of a MentionEmailGenerated.
         * @memberof events
         * @interface IMentionEmailGenerated
         * @property {string|null} [event] MentionEmailGenerated event
         * @property {string|null} [type] MentionEmailGenerated type
         * @property {string|null} [serviceName] MentionEmailGenerated serviceName
         * @property {string|null} [toEmail] MentionEmailGenerated toEmail
         * @property {string|null} [fromEmail] MentionEmailGenerated fromEmail
         * @property {string|null} [fromName] MentionEmailGenerated fromName
         * @property {string|null} [template] MentionEmailGenerated template
         * @property {events.MentionEmailGenerated.IPlaceHolders|null} [placeHolders] MentionEmailGenerated placeHolders
         * @property {string|null} [mergeLanguage] MentionEmailGenerated mergeLanguage
         */

        /**
         * Constructs a new MentionEmailGenerated.
         * @memberof events
         * @classdesc Represents a MentionEmailGenerated.
         * @implements IMentionEmailGenerated
         * @constructor
         * @param {events.IMentionEmailGenerated=} [properties] Properties to set
         */
        function MentionEmailGenerated(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MentionEmailGenerated event.
         * @member {string} event
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.event = "";

        /**
         * MentionEmailGenerated type.
         * @member {string} type
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.type = "";

        /**
         * MentionEmailGenerated serviceName.
         * @member {string} serviceName
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.serviceName = "";

        /**
         * MentionEmailGenerated toEmail.
         * @member {string} toEmail
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.toEmail = "";

        /**
         * MentionEmailGenerated fromEmail.
         * @member {string} fromEmail
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.fromEmail = "";

        /**
         * MentionEmailGenerated fromName.
         * @member {string} fromName
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.fromName = "";

        /**
         * MentionEmailGenerated template.
         * @member {string} template
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.template = "";

        /**
         * MentionEmailGenerated placeHolders.
         * @member {events.MentionEmailGenerated.IPlaceHolders|null|undefined} placeHolders
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.placeHolders = null;

        /**
         * MentionEmailGenerated mergeLanguage.
         * @member {string} mergeLanguage
         * @memberof events.MentionEmailGenerated
         * @instance
         */
        MentionEmailGenerated.prototype.mergeLanguage = "";

        /**
         * Creates a new MentionEmailGenerated instance using the specified properties.
         * @function create
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {events.IMentionEmailGenerated=} [properties] Properties to set
         * @returns {events.MentionEmailGenerated} MentionEmailGenerated instance
         */
        MentionEmailGenerated.create = function create(properties) {
            return new MentionEmailGenerated(properties);
        };

        /**
         * Encodes the specified MentionEmailGenerated message. Does not implicitly {@link events.MentionEmailGenerated.verify|verify} messages.
         * @function encode
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {events.IMentionEmailGenerated} message MentionEmailGenerated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionEmailGenerated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && message.hasOwnProperty("event"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.event);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.serviceName);
            if (message.toEmail != null && message.hasOwnProperty("toEmail"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.toEmail);
            if (message.fromEmail != null && message.hasOwnProperty("fromEmail"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromEmail);
            if (message.fromName != null && message.hasOwnProperty("fromName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fromName);
            if (message.template != null && message.hasOwnProperty("template"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.template);
            if (message.placeHolders != null && message.hasOwnProperty("placeHolders"))
                $root.events.MentionEmailGenerated.PlaceHolders.encode(message.placeHolders, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.mergeLanguage != null && message.hasOwnProperty("mergeLanguage"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.mergeLanguage);
            return writer;
        };

        /**
         * Encodes the specified MentionEmailGenerated message, length delimited. Does not implicitly {@link events.MentionEmailGenerated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {events.IMentionEmailGenerated} message MentionEmailGenerated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionEmailGenerated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MentionEmailGenerated message from the specified reader or buffer.
         * @function decode
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.MentionEmailGenerated} MentionEmailGenerated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionEmailGenerated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.MentionEmailGenerated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.event = reader.string();
                    break;
                case 4:
                    message.type = reader.string();
                    break;
                case 5:
                    message.serviceName = reader.string();
                    break;
                case 6:
                    message.toEmail = reader.string();
                    break;
                case 7:
                    message.fromEmail = reader.string();
                    break;
                case 8:
                    message.fromName = reader.string();
                    break;
                case 9:
                    message.template = reader.string();
                    break;
                case 10:
                    message.placeHolders = $root.events.MentionEmailGenerated.PlaceHolders.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.mergeLanguage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MentionEmailGenerated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.MentionEmailGenerated} MentionEmailGenerated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionEmailGenerated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MentionEmailGenerated message.
         * @function verify
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MentionEmailGenerated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isString(message.event))
                    return "event: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                if (!$util.isString(message.serviceName))
                    return "serviceName: string expected";
            if (message.toEmail != null && message.hasOwnProperty("toEmail"))
                if (!$util.isString(message.toEmail))
                    return "toEmail: string expected";
            if (message.fromEmail != null && message.hasOwnProperty("fromEmail"))
                if (!$util.isString(message.fromEmail))
                    return "fromEmail: string expected";
            if (message.fromName != null && message.hasOwnProperty("fromName"))
                if (!$util.isString(message.fromName))
                    return "fromName: string expected";
            if (message.template != null && message.hasOwnProperty("template"))
                if (!$util.isString(message.template))
                    return "template: string expected";
            if (message.placeHolders != null && message.hasOwnProperty("placeHolders")) {
                var error = $root.events.MentionEmailGenerated.PlaceHolders.verify(message.placeHolders);
                if (error)
                    return "placeHolders." + error;
            }
            if (message.mergeLanguage != null && message.hasOwnProperty("mergeLanguage"))
                if (!$util.isString(message.mergeLanguage))
                    return "mergeLanguage: string expected";
            return null;
        };

        /**
         * Creates a MentionEmailGenerated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.MentionEmailGenerated} MentionEmailGenerated
         */
        MentionEmailGenerated.fromObject = function fromObject(object) {
            if (object instanceof $root.events.MentionEmailGenerated)
                return object;
            var message = new $root.events.MentionEmailGenerated();
            if (object.event != null)
                message.event = String(object.event);
            if (object.type != null)
                message.type = String(object.type);
            if (object.serviceName != null)
                message.serviceName = String(object.serviceName);
            if (object.toEmail != null)
                message.toEmail = String(object.toEmail);
            if (object.fromEmail != null)
                message.fromEmail = String(object.fromEmail);
            if (object.fromName != null)
                message.fromName = String(object.fromName);
            if (object.template != null)
                message.template = String(object.template);
            if (object.placeHolders != null) {
                if (typeof object.placeHolders !== "object")
                    throw TypeError(".events.MentionEmailGenerated.placeHolders: object expected");
                message.placeHolders = $root.events.MentionEmailGenerated.PlaceHolders.fromObject(object.placeHolders);
            }
            if (object.mergeLanguage != null)
                message.mergeLanguage = String(object.mergeLanguage);
            return message;
        };

        /**
         * Creates a plain object from a MentionEmailGenerated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.MentionEmailGenerated
         * @static
         * @param {events.MentionEmailGenerated} message MentionEmailGenerated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MentionEmailGenerated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event = "";
                object.type = "";
                object.serviceName = "";
                object.toEmail = "";
                object.fromEmail = "";
                object.fromName = "";
                object.template = "";
                object.placeHolders = null;
                object.mergeLanguage = "";
            }
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                object.serviceName = message.serviceName;
            if (message.toEmail != null && message.hasOwnProperty("toEmail"))
                object.toEmail = message.toEmail;
            if (message.fromEmail != null && message.hasOwnProperty("fromEmail"))
                object.fromEmail = message.fromEmail;
            if (message.fromName != null && message.hasOwnProperty("fromName"))
                object.fromName = message.fromName;
            if (message.template != null && message.hasOwnProperty("template"))
                object.template = message.template;
            if (message.placeHolders != null && message.hasOwnProperty("placeHolders"))
                object.placeHolders = $root.events.MentionEmailGenerated.PlaceHolders.toObject(message.placeHolders, options);
            if (message.mergeLanguage != null && message.hasOwnProperty("mergeLanguage"))
                object.mergeLanguage = message.mergeLanguage;
            return object;
        };

        /**
         * Converts this MentionEmailGenerated to JSON.
         * @function toJSON
         * @memberof events.MentionEmailGenerated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MentionEmailGenerated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MentionEmailGenerated.Mention = (function() {

            /**
             * Properties of a Mention.
             * @memberof events.MentionEmailGenerated
             * @interface IMention
             * @property {string|null} [trackingUnitName] Mention trackingUnitName
             * @property {string|null} [programName] Mention programName
             * @property {string|null} [programImage] Mention programImage
             * @property {number|Long|null} [mentionDate] Mention mentionDate
             * @property {string|null} [snippets] Mention snippets
             * @property {string|null} [inviteLink] Mention inviteLink
             * @property {string|null} [via] Mention via
             * @property {string|null} [logouri] Mention logouri
             * @property {string|null} [creatorEmail] Mention creatorEmail
             * @property {string|null} [unsubscribeHash] Mention unsubscribeHash
             * @property {string|null} [unsubscribeLink] Mention unsubscribeLink
             */

            /**
             * Constructs a new Mention.
             * @memberof events.MentionEmailGenerated
             * @classdesc Represents a Mention.
             * @implements IMention
             * @constructor
             * @param {events.MentionEmailGenerated.IMention=} [properties] Properties to set
             */
            function Mention(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mention trackingUnitName.
             * @member {string} trackingUnitName
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.trackingUnitName = "";

            /**
             * Mention programName.
             * @member {string} programName
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.programName = "";

            /**
             * Mention programImage.
             * @member {string} programImage
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.programImage = "";

            /**
             * Mention mentionDate.
             * @member {number|Long} mentionDate
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.mentionDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mention snippets.
             * @member {string} snippets
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.snippets = "";

            /**
             * Mention inviteLink.
             * @member {string} inviteLink
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.inviteLink = "";

            /**
             * Mention via.
             * @member {string} via
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.via = "";

            /**
             * Mention logouri.
             * @member {string} logouri
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.logouri = "";

            /**
             * Mention creatorEmail.
             * @member {string} creatorEmail
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.creatorEmail = "";

            /**
             * Mention unsubscribeHash.
             * @member {string} unsubscribeHash
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.unsubscribeHash = "";

            /**
             * Mention unsubscribeLink.
             * @member {string} unsubscribeLink
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             */
            Mention.prototype.unsubscribeLink = "";

            /**
             * Creates a new Mention instance using the specified properties.
             * @function create
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {events.MentionEmailGenerated.IMention=} [properties] Properties to set
             * @returns {events.MentionEmailGenerated.Mention} Mention instance
             */
            Mention.create = function create(properties) {
                return new Mention(properties);
            };

            /**
             * Encodes the specified Mention message. Does not implicitly {@link events.MentionEmailGenerated.Mention.verify|verify} messages.
             * @function encode
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {events.MentionEmailGenerated.IMention} message Mention message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mention.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackingUnitName);
                if (message.programName != null && message.hasOwnProperty("programName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.programName);
                if (message.programImage != null && message.hasOwnProperty("programImage"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.programImage);
                if (message.mentionDate != null && message.hasOwnProperty("mentionDate"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.mentionDate);
                if (message.snippets != null && message.hasOwnProperty("snippets"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.snippets);
                if (message.inviteLink != null && message.hasOwnProperty("inviteLink"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.inviteLink);
                if (message.via != null && message.hasOwnProperty("via"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.via);
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.logouri);
                if (message.creatorEmail != null && message.hasOwnProperty("creatorEmail"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.creatorEmail);
                if (message.unsubscribeHash != null && message.hasOwnProperty("unsubscribeHash"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.unsubscribeHash);
                if (message.unsubscribeLink != null && message.hasOwnProperty("unsubscribeLink"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.unsubscribeLink);
                return writer;
            };

            /**
             * Encodes the specified Mention message, length delimited. Does not implicitly {@link events.MentionEmailGenerated.Mention.verify|verify} messages.
             * @function encodeDelimited
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {events.MentionEmailGenerated.IMention} message Mention message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mention.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mention message from the specified reader or buffer.
             * @function decode
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {events.MentionEmailGenerated.Mention} Mention
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mention.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.MentionEmailGenerated.Mention();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.trackingUnitName = reader.string();
                        break;
                    case 2:
                        message.programName = reader.string();
                        break;
                    case 3:
                        message.programImage = reader.string();
                        break;
                    case 4:
                        message.mentionDate = reader.int64();
                        break;
                    case 5:
                        message.snippets = reader.string();
                        break;
                    case 6:
                        message.inviteLink = reader.string();
                        break;
                    case 7:
                        message.via = reader.string();
                        break;
                    case 8:
                        message.logouri = reader.string();
                        break;
                    case 9:
                        message.creatorEmail = reader.string();
                        break;
                    case 10:
                        message.unsubscribeHash = reader.string();
                        break;
                    case 11:
                        message.unsubscribeLink = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mention message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {events.MentionEmailGenerated.Mention} Mention
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mention.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mention message.
             * @function verify
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mention.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    if (!$util.isString(message.trackingUnitName))
                        return "trackingUnitName: string expected";
                if (message.programName != null && message.hasOwnProperty("programName"))
                    if (!$util.isString(message.programName))
                        return "programName: string expected";
                if (message.programImage != null && message.hasOwnProperty("programImage"))
                    if (!$util.isString(message.programImage))
                        return "programImage: string expected";
                if (message.mentionDate != null && message.hasOwnProperty("mentionDate"))
                    if (!$util.isInteger(message.mentionDate) && !(message.mentionDate && $util.isInteger(message.mentionDate.low) && $util.isInteger(message.mentionDate.high)))
                        return "mentionDate: integer|Long expected";
                if (message.snippets != null && message.hasOwnProperty("snippets"))
                    if (!$util.isString(message.snippets))
                        return "snippets: string expected";
                if (message.inviteLink != null && message.hasOwnProperty("inviteLink"))
                    if (!$util.isString(message.inviteLink))
                        return "inviteLink: string expected";
                if (message.via != null && message.hasOwnProperty("via"))
                    if (!$util.isString(message.via))
                        return "via: string expected";
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    if (!$util.isString(message.logouri))
                        return "logouri: string expected";
                if (message.creatorEmail != null && message.hasOwnProperty("creatorEmail"))
                    if (!$util.isString(message.creatorEmail))
                        return "creatorEmail: string expected";
                if (message.unsubscribeHash != null && message.hasOwnProperty("unsubscribeHash"))
                    if (!$util.isString(message.unsubscribeHash))
                        return "unsubscribeHash: string expected";
                if (message.unsubscribeLink != null && message.hasOwnProperty("unsubscribeLink"))
                    if (!$util.isString(message.unsubscribeLink))
                        return "unsubscribeLink: string expected";
                return null;
            };

            /**
             * Creates a Mention message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {events.MentionEmailGenerated.Mention} Mention
             */
            Mention.fromObject = function fromObject(object) {
                if (object instanceof $root.events.MentionEmailGenerated.Mention)
                    return object;
                var message = new $root.events.MentionEmailGenerated.Mention();
                if (object.trackingUnitName != null)
                    message.trackingUnitName = String(object.trackingUnitName);
                if (object.programName != null)
                    message.programName = String(object.programName);
                if (object.programImage != null)
                    message.programImage = String(object.programImage);
                if (object.mentionDate != null)
                    if ($util.Long)
                        (message.mentionDate = $util.Long.fromValue(object.mentionDate)).unsigned = false;
                    else if (typeof object.mentionDate === "string")
                        message.mentionDate = parseInt(object.mentionDate, 10);
                    else if (typeof object.mentionDate === "number")
                        message.mentionDate = object.mentionDate;
                    else if (typeof object.mentionDate === "object")
                        message.mentionDate = new $util.LongBits(object.mentionDate.low >>> 0, object.mentionDate.high >>> 0).toNumber();
                if (object.snippets != null)
                    message.snippets = String(object.snippets);
                if (object.inviteLink != null)
                    message.inviteLink = String(object.inviteLink);
                if (object.via != null)
                    message.via = String(object.via);
                if (object.logouri != null)
                    message.logouri = String(object.logouri);
                if (object.creatorEmail != null)
                    message.creatorEmail = String(object.creatorEmail);
                if (object.unsubscribeHash != null)
                    message.unsubscribeHash = String(object.unsubscribeHash);
                if (object.unsubscribeLink != null)
                    message.unsubscribeLink = String(object.unsubscribeLink);
                return message;
            };

            /**
             * Creates a plain object from a Mention message. Also converts values to other types if specified.
             * @function toObject
             * @memberof events.MentionEmailGenerated.Mention
             * @static
             * @param {events.MentionEmailGenerated.Mention} message Mention
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mention.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.trackingUnitName = "";
                    object.programName = "";
                    object.programImage = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.mentionDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.mentionDate = options.longs === String ? "0" : 0;
                    object.snippets = "";
                    object.inviteLink = "";
                    object.via = "";
                    object.logouri = "";
                    object.creatorEmail = "";
                    object.unsubscribeHash = "";
                    object.unsubscribeLink = "";
                }
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    object.trackingUnitName = message.trackingUnitName;
                if (message.programName != null && message.hasOwnProperty("programName"))
                    object.programName = message.programName;
                if (message.programImage != null && message.hasOwnProperty("programImage"))
                    object.programImage = message.programImage;
                if (message.mentionDate != null && message.hasOwnProperty("mentionDate"))
                    if (typeof message.mentionDate === "number")
                        object.mentionDate = options.longs === String ? String(message.mentionDate) : message.mentionDate;
                    else
                        object.mentionDate = options.longs === String ? $util.Long.prototype.toString.call(message.mentionDate) : options.longs === Number ? new $util.LongBits(message.mentionDate.low >>> 0, message.mentionDate.high >>> 0).toNumber() : message.mentionDate;
                if (message.snippets != null && message.hasOwnProperty("snippets"))
                    object.snippets = message.snippets;
                if (message.inviteLink != null && message.hasOwnProperty("inviteLink"))
                    object.inviteLink = message.inviteLink;
                if (message.via != null && message.hasOwnProperty("via"))
                    object.via = message.via;
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    object.logouri = message.logouri;
                if (message.creatorEmail != null && message.hasOwnProperty("creatorEmail"))
                    object.creatorEmail = message.creatorEmail;
                if (message.unsubscribeHash != null && message.hasOwnProperty("unsubscribeHash"))
                    object.unsubscribeHash = message.unsubscribeHash;
                if (message.unsubscribeLink != null && message.hasOwnProperty("unsubscribeLink"))
                    object.unsubscribeLink = message.unsubscribeLink;
                return object;
            };

            /**
             * Converts this Mention to JSON.
             * @function toJSON
             * @memberof events.MentionEmailGenerated.Mention
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mention.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mention;
        })();

        MentionEmailGenerated.PlaceHolders = (function() {

            /**
             * Properties of a PlaceHolders.
             * @memberof events.MentionEmailGenerated
             * @interface IPlaceHolders
             * @property {string|null} [trackingUnitName] PlaceHolders trackingUnitName
             * @property {string|null} [via] PlaceHolders via
             * @property {string|null} [logouri] PlaceHolders logouri
             * @property {Array.<events.MentionEmailGenerated.IMention>|null} [mentions] PlaceHolders mentions
             */

            /**
             * Constructs a new PlaceHolders.
             * @memberof events.MentionEmailGenerated
             * @classdesc Represents a PlaceHolders.
             * @implements IPlaceHolders
             * @constructor
             * @param {events.MentionEmailGenerated.IPlaceHolders=} [properties] Properties to set
             */
            function PlaceHolders(properties) {
                this.mentions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlaceHolders trackingUnitName.
             * @member {string} trackingUnitName
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @instance
             */
            PlaceHolders.prototype.trackingUnitName = "";

            /**
             * PlaceHolders via.
             * @member {string} via
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @instance
             */
            PlaceHolders.prototype.via = "";

            /**
             * PlaceHolders logouri.
             * @member {string} logouri
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @instance
             */
            PlaceHolders.prototype.logouri = "";

            /**
             * PlaceHolders mentions.
             * @member {Array.<events.MentionEmailGenerated.IMention>} mentions
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @instance
             */
            PlaceHolders.prototype.mentions = $util.emptyArray;

            /**
             * Creates a new PlaceHolders instance using the specified properties.
             * @function create
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {events.MentionEmailGenerated.IPlaceHolders=} [properties] Properties to set
             * @returns {events.MentionEmailGenerated.PlaceHolders} PlaceHolders instance
             */
            PlaceHolders.create = function create(properties) {
                return new PlaceHolders(properties);
            };

            /**
             * Encodes the specified PlaceHolders message. Does not implicitly {@link events.MentionEmailGenerated.PlaceHolders.verify|verify} messages.
             * @function encode
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {events.MentionEmailGenerated.IPlaceHolders} message PlaceHolders message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlaceHolders.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackingUnitName);
                if (message.via != null && message.hasOwnProperty("via"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.via);
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.logouri);
                if (message.mentions != null && message.mentions.length)
                    for (var i = 0; i < message.mentions.length; ++i)
                        $root.events.MentionEmailGenerated.Mention.encode(message.mentions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PlaceHolders message, length delimited. Does not implicitly {@link events.MentionEmailGenerated.PlaceHolders.verify|verify} messages.
             * @function encodeDelimited
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {events.MentionEmailGenerated.IPlaceHolders} message PlaceHolders message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlaceHolders.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlaceHolders message from the specified reader or buffer.
             * @function decode
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {events.MentionEmailGenerated.PlaceHolders} PlaceHolders
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlaceHolders.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.MentionEmailGenerated.PlaceHolders();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.trackingUnitName = reader.string();
                        break;
                    case 2:
                        message.via = reader.string();
                        break;
                    case 3:
                        message.logouri = reader.string();
                        break;
                    case 4:
                        if (!(message.mentions && message.mentions.length))
                            message.mentions = [];
                        message.mentions.push($root.events.MentionEmailGenerated.Mention.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PlaceHolders message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {events.MentionEmailGenerated.PlaceHolders} PlaceHolders
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlaceHolders.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlaceHolders message.
             * @function verify
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlaceHolders.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    if (!$util.isString(message.trackingUnitName))
                        return "trackingUnitName: string expected";
                if (message.via != null && message.hasOwnProperty("via"))
                    if (!$util.isString(message.via))
                        return "via: string expected";
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    if (!$util.isString(message.logouri))
                        return "logouri: string expected";
                if (message.mentions != null && message.hasOwnProperty("mentions")) {
                    if (!Array.isArray(message.mentions))
                        return "mentions: array expected";
                    for (var i = 0; i < message.mentions.length; ++i) {
                        var error = $root.events.MentionEmailGenerated.Mention.verify(message.mentions[i]);
                        if (error)
                            return "mentions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PlaceHolders message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {events.MentionEmailGenerated.PlaceHolders} PlaceHolders
             */
            PlaceHolders.fromObject = function fromObject(object) {
                if (object instanceof $root.events.MentionEmailGenerated.PlaceHolders)
                    return object;
                var message = new $root.events.MentionEmailGenerated.PlaceHolders();
                if (object.trackingUnitName != null)
                    message.trackingUnitName = String(object.trackingUnitName);
                if (object.via != null)
                    message.via = String(object.via);
                if (object.logouri != null)
                    message.logouri = String(object.logouri);
                if (object.mentions) {
                    if (!Array.isArray(object.mentions))
                        throw TypeError(".events.MentionEmailGenerated.PlaceHolders.mentions: array expected");
                    message.mentions = [];
                    for (var i = 0; i < object.mentions.length; ++i) {
                        if (typeof object.mentions[i] !== "object")
                            throw TypeError(".events.MentionEmailGenerated.PlaceHolders.mentions: object expected");
                        message.mentions[i] = $root.events.MentionEmailGenerated.Mention.fromObject(object.mentions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PlaceHolders message. Also converts values to other types if specified.
             * @function toObject
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @static
             * @param {events.MentionEmailGenerated.PlaceHolders} message PlaceHolders
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlaceHolders.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.mentions = [];
                if (options.defaults) {
                    object.trackingUnitName = "";
                    object.via = "";
                    object.logouri = "";
                }
                if (message.trackingUnitName != null && message.hasOwnProperty("trackingUnitName"))
                    object.trackingUnitName = message.trackingUnitName;
                if (message.via != null && message.hasOwnProperty("via"))
                    object.via = message.via;
                if (message.logouri != null && message.hasOwnProperty("logouri"))
                    object.logouri = message.logouri;
                if (message.mentions && message.mentions.length) {
                    object.mentions = [];
                    for (var j = 0; j < message.mentions.length; ++j)
                        object.mentions[j] = $root.events.MentionEmailGenerated.Mention.toObject(message.mentions[j], options);
                }
                return object;
            };

            /**
             * Converts this PlaceHolders to JSON.
             * @function toJSON
             * @memberof events.MentionEmailGenerated.PlaceHolders
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlaceHolders.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PlaceHolders;
        })();

        return MentionEmailGenerated;
    })();

    events.BasicEmail = (function() {

        /**
         * Properties of a BasicEmail.
         * @memberof events
         * @interface IBasicEmail
         * @property {string|null} [fromAddress] BasicEmail fromAddress
         * @property {string|null} [toAddress] BasicEmail toAddress
         * @property {string|null} [subject] BasicEmail subject
         * @property {string|null} [body] BasicEmail body
         */

        /**
         * Constructs a new BasicEmail.
         * @memberof events
         * @classdesc Represents a BasicEmail.
         * @implements IBasicEmail
         * @constructor
         * @param {events.IBasicEmail=} [properties] Properties to set
         */
        function BasicEmail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicEmail fromAddress.
         * @member {string} fromAddress
         * @memberof events.BasicEmail
         * @instance
         */
        BasicEmail.prototype.fromAddress = "";

        /**
         * BasicEmail toAddress.
         * @member {string} toAddress
         * @memberof events.BasicEmail
         * @instance
         */
        BasicEmail.prototype.toAddress = "";

        /**
         * BasicEmail subject.
         * @member {string} subject
         * @memberof events.BasicEmail
         * @instance
         */
        BasicEmail.prototype.subject = "";

        /**
         * BasicEmail body.
         * @member {string} body
         * @memberof events.BasicEmail
         * @instance
         */
        BasicEmail.prototype.body = "";

        /**
         * Creates a new BasicEmail instance using the specified properties.
         * @function create
         * @memberof events.BasicEmail
         * @static
         * @param {events.IBasicEmail=} [properties] Properties to set
         * @returns {events.BasicEmail} BasicEmail instance
         */
        BasicEmail.create = function create(properties) {
            return new BasicEmail(properties);
        };

        /**
         * Encodes the specified BasicEmail message. Does not implicitly {@link events.BasicEmail.verify|verify} messages.
         * @function encode
         * @memberof events.BasicEmail
         * @static
         * @param {events.IBasicEmail} message BasicEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicEmail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.fromAddress);
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.toAddress);
            if (message.subject != null && message.hasOwnProperty("subject"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.subject);
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.body);
            return writer;
        };

        /**
         * Encodes the specified BasicEmail message, length delimited. Does not implicitly {@link events.BasicEmail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.BasicEmail
         * @static
         * @param {events.IBasicEmail} message BasicEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicEmail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicEmail message from the specified reader or buffer.
         * @function decode
         * @memberof events.BasicEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.BasicEmail} BasicEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicEmail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.BasicEmail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10:
                    message.fromAddress = reader.string();
                    break;
                case 11:
                    message.toAddress = reader.string();
                    break;
                case 12:
                    message.subject = reader.string();
                    break;
                case 13:
                    message.body = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BasicEmail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.BasicEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.BasicEmail} BasicEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicEmail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicEmail message.
         * @function verify
         * @memberof events.BasicEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicEmail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                if (!$util.isString(message.fromAddress))
                    return "fromAddress: string expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!$util.isString(message.toAddress))
                    return "toAddress: string expected";
            if (message.subject != null && message.hasOwnProperty("subject"))
                if (!$util.isString(message.subject))
                    return "subject: string expected";
            if (message.body != null && message.hasOwnProperty("body"))
                if (!$util.isString(message.body))
                    return "body: string expected";
            return null;
        };

        /**
         * Creates a BasicEmail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.BasicEmail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.BasicEmail} BasicEmail
         */
        BasicEmail.fromObject = function fromObject(object) {
            if (object instanceof $root.events.BasicEmail)
                return object;
            var message = new $root.events.BasicEmail();
            if (object.fromAddress != null)
                message.fromAddress = String(object.fromAddress);
            if (object.toAddress != null)
                message.toAddress = String(object.toAddress);
            if (object.subject != null)
                message.subject = String(object.subject);
            if (object.body != null)
                message.body = String(object.body);
            return message;
        };

        /**
         * Creates a plain object from a BasicEmail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.BasicEmail
         * @static
         * @param {events.BasicEmail} message BasicEmail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicEmail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fromAddress = "";
                object.toAddress = "";
                object.subject = "";
                object.body = "";
            }
            if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                object.fromAddress = message.fromAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = message.toAddress;
            if (message.subject != null && message.hasOwnProperty("subject"))
                object.subject = message.subject;
            if (message.body != null && message.hasOwnProperty("body"))
                object.body = message.body;
            return object;
        };

        /**
         * Converts this BasicEmail to JSON.
         * @function toJSON
         * @memberof events.BasicEmail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicEmail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicEmail;
    })();

    events.SMSNotification = (function() {

        /**
         * Properties of a SMSNotification.
         * @memberof events
         * @interface ISMSNotification
         * @property {string|null} [fromNumber] SMSNotification fromNumber
         * @property {string|null} [toNumber] SMSNotification toNumber
         * @property {string|null} [message] SMSNotification message
         */

        /**
         * Constructs a new SMSNotification.
         * @memberof events
         * @classdesc Represents a SMSNotification.
         * @implements ISMSNotification
         * @constructor
         * @param {events.ISMSNotification=} [properties] Properties to set
         */
        function SMSNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SMSNotification fromNumber.
         * @member {string} fromNumber
         * @memberof events.SMSNotification
         * @instance
         */
        SMSNotification.prototype.fromNumber = "";

        /**
         * SMSNotification toNumber.
         * @member {string} toNumber
         * @memberof events.SMSNotification
         * @instance
         */
        SMSNotification.prototype.toNumber = "";

        /**
         * SMSNotification message.
         * @member {string} message
         * @memberof events.SMSNotification
         * @instance
         */
        SMSNotification.prototype.message = "";

        /**
         * Creates a new SMSNotification instance using the specified properties.
         * @function create
         * @memberof events.SMSNotification
         * @static
         * @param {events.ISMSNotification=} [properties] Properties to set
         * @returns {events.SMSNotification} SMSNotification instance
         */
        SMSNotification.create = function create(properties) {
            return new SMSNotification(properties);
        };

        /**
         * Encodes the specified SMSNotification message. Does not implicitly {@link events.SMSNotification.verify|verify} messages.
         * @function encode
         * @memberof events.SMSNotification
         * @static
         * @param {events.ISMSNotification} message SMSNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SMSNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fromNumber != null && message.hasOwnProperty("fromNumber"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.fromNumber);
            if (message.toNumber != null && message.hasOwnProperty("toNumber"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.toNumber);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified SMSNotification message, length delimited. Does not implicitly {@link events.SMSNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.SMSNotification
         * @static
         * @param {events.ISMSNotification} message SMSNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SMSNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SMSNotification message from the specified reader or buffer.
         * @function decode
         * @memberof events.SMSNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.SMSNotification} SMSNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SMSNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.SMSNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10:
                    message.fromNumber = reader.string();
                    break;
                case 11:
                    message.toNumber = reader.string();
                    break;
                case 12:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SMSNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.SMSNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.SMSNotification} SMSNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SMSNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SMSNotification message.
         * @function verify
         * @memberof events.SMSNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SMSNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fromNumber != null && message.hasOwnProperty("fromNumber"))
                if (!$util.isString(message.fromNumber))
                    return "fromNumber: string expected";
            if (message.toNumber != null && message.hasOwnProperty("toNumber"))
                if (!$util.isString(message.toNumber))
                    return "toNumber: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a SMSNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.SMSNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.SMSNotification} SMSNotification
         */
        SMSNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.events.SMSNotification)
                return object;
            var message = new $root.events.SMSNotification();
            if (object.fromNumber != null)
                message.fromNumber = String(object.fromNumber);
            if (object.toNumber != null)
                message.toNumber = String(object.toNumber);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a SMSNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.SMSNotification
         * @static
         * @param {events.SMSNotification} message SMSNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SMSNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fromNumber = "";
                object.toNumber = "";
                object.message = "";
            }
            if (message.fromNumber != null && message.hasOwnProperty("fromNumber"))
                object.fromNumber = message.fromNumber;
            if (message.toNumber != null && message.hasOwnProperty("toNumber"))
                object.toNumber = message.toNumber;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this SMSNotification to JSON.
         * @function toJSON
         * @memberof events.SMSNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SMSNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SMSNotification;
    })();

    events.TriggerCacheRefresh = (function() {

        /**
         * Properties of a TriggerCacheRefresh.
         * @memberof events
         * @interface ITriggerCacheRefresh
         */

        /**
         * Constructs a new TriggerCacheRefresh.
         * @memberof events
         * @classdesc Represents a TriggerCacheRefresh.
         * @implements ITriggerCacheRefresh
         * @constructor
         * @param {events.ITriggerCacheRefresh=} [properties] Properties to set
         */
        function TriggerCacheRefresh(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TriggerCacheRefresh instance using the specified properties.
         * @function create
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {events.ITriggerCacheRefresh=} [properties] Properties to set
         * @returns {events.TriggerCacheRefresh} TriggerCacheRefresh instance
         */
        TriggerCacheRefresh.create = function create(properties) {
            return new TriggerCacheRefresh(properties);
        };

        /**
         * Encodes the specified TriggerCacheRefresh message. Does not implicitly {@link events.TriggerCacheRefresh.verify|verify} messages.
         * @function encode
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {events.ITriggerCacheRefresh} message TriggerCacheRefresh message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerCacheRefresh.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TriggerCacheRefresh message, length delimited. Does not implicitly {@link events.TriggerCacheRefresh.verify|verify} messages.
         * @function encodeDelimited
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {events.ITriggerCacheRefresh} message TriggerCacheRefresh message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerCacheRefresh.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TriggerCacheRefresh message from the specified reader or buffer.
         * @function decode
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {events.TriggerCacheRefresh} TriggerCacheRefresh
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerCacheRefresh.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.events.TriggerCacheRefresh();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TriggerCacheRefresh message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {events.TriggerCacheRefresh} TriggerCacheRefresh
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerCacheRefresh.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TriggerCacheRefresh message.
         * @function verify
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TriggerCacheRefresh.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a TriggerCacheRefresh message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {events.TriggerCacheRefresh} TriggerCacheRefresh
         */
        TriggerCacheRefresh.fromObject = function fromObject(object) {
            if (object instanceof $root.events.TriggerCacheRefresh)
                return object;
            return new $root.events.TriggerCacheRefresh();
        };

        /**
         * Creates a plain object from a TriggerCacheRefresh message. Also converts values to other types if specified.
         * @function toObject
         * @memberof events.TriggerCacheRefresh
         * @static
         * @param {events.TriggerCacheRefresh} message TriggerCacheRefresh
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TriggerCacheRefresh.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TriggerCacheRefresh to JSON.
         * @function toJSON
         * @memberof events.TriggerCacheRefresh
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TriggerCacheRefresh.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TriggerCacheRefresh;
    })();

    return events;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    object.value = options.bytes === String ? "" : [];
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
